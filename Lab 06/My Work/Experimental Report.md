# 数据结构描述
complete binary min-heap是满足下列三个条件的数据结构：
1. 从每个节点出发，都是一个complete binary min-heap；
2. 每个节点的key值都小于自己的两个（如果有的话）子节点的key值。
3. 叶节点深度差不超过1，即是一棵完全树。

# 数据结构设计
由于该数据结构是一个完全树，因此可以考虑使用线性表来实现该数据结构。即如下图：

![min_heap](..\Image\min_heap.png)

这样，我们可以很简单的发现两个规律：

1. 设任一节点的下标为 $ i $，那么该节点的两个子节点（若有的话）的下标为 $ 2i,2i+1 $ ；
2. 设任一节点的下标为 $ i $，那么该节点的父节点（若有的话）的下标为 $ \frac{i}{2} $ 。

# 算法流程



## push

1. 若数组为空，则返回输入元素；
2. 在数组最后附上输入元素， $ size $ 加一， 令 $ i=size , i_{pre}=0 $ ；
3. 若 $ i $ 与 $i_{pre} $  相等，则返回；否则令 $ i_{pre}=i $ ，然后让 $ i $ 为第 $ i $ 个元素及其所对应的堆节点的父节点（若有的话）的元素中最小的元素的下标。重复步骤 3。

## pop
1. 若数组为空或者只有一个元素，则返回空数组；
2. 让数组第一个元素等于最后一个元素， $ size $ 减一，令 $ i=1 , i_{pre}=0 $ ；
3. 若 $ i $ 与 $i_{pre} $  相等，则返回；否则令 $ i_{pre}=i $ ，然后让 $ i $ 为第 $ i $ 个元素及其所对应的堆节点的两个子节点（若有的话）的元素中最小的元素的下标。重复步骤 3。

## display

如之前每个树形数据结构一样，都是进行中序递归，先展示左子树，再展示中间节点，最后展示右子树，展示的时候根据深度大小输出不同长度的空字符，这里不再赘述。

# 测例设计与程序测试

我们需要在任一操作结束后对数据结构进行下列项检查：

1. 是否正确完成了操作对应的任务；
2. 是否还是一个complete binary min-heap，即是否依然满足报告一开始提出的三个条件。

## 功能测试

在功能测试中，每个功能的测试都是该功能输入的极限情况。

### push

对于push，我们通过从大到小的顺序输入，能够使得每次输入的值都是最小值，都需要被换到堆顶，以此来查看功能的正确性。

不过最后我们还是会给一个中间值看其会不会正常停止在半路。

因此我们测例输入如下：

```c++
for (int i = 20 ; i>=2 ; i=i-2) //按从大到小的顺序push进20以下的偶数
	m_heap.push(i);
m_heap.push(11); //push奇数11
```

最终的树形展示与数组存储情况如下：

![t](..\Image\t1.png)



### pop

对于pop，我们希望每次交换上来的值都是最大值，因此我们不能直接用上述测例之后的结果，我们通过从小到大的顺序进行push，然后再pop，这样就满足了极限情况。

不过就像push测例一样，最后我们还是会给一个中间值看其会不会正常停止在半路。

因此我们测例输入如下：

```c++
for (int i = 2 ; i<=20 ; i=i+2) //按从小到大的顺序push进20以下的偶数
    m_heap.push(i);
m_heap.push(11); //push进奇数11
```

此时树形展示与数组存储情况如下：

![t](..\Image\t2_1.png)



接着进行pop的测试

```c++
for (int j = 0; j < 5; ++j) //只pop5次就可以了，全pop出去无法查看树形情况
    m_heap.pop();
```

最终的树形展示与数组存储情况如下：

![t](..\Image\t2_2.png)

## 随机测试

利用随机测试查看没有搞考虑到的情况下的工作情况。

具体实现如下：

```c++
int n=rand()%10+25; //操作次数由随机数决定
while (n--){
    int flag=rand()%2; //每次操作由随机数决定操作类型
    if(flag==1)
        m_heap.push(rand()%10000); //若为push则由随机数
    else
        m_heap.pop();
}
```

进行三次随机测试，每次的最终树形展示与数组存储情况如下：

第一次：

![t](..\Image\t3_1.png)

第二次：

![t](..\Image\t3_2.png)

第三次：

![t](..\Image\t3_3.png)

# 复杂度分析

老师课件里有非常简单的证明，这里就不再推导一遍了。

| 操作 | 最好情况                       | 最坏情况                           | 平均情况                       |
| ---- | ------------------------------ | ---------------------------------- | ------------------------------ |
| push | $ \varTheta \left( 1 \right) $ | $ \varTheta \left( ln(n) \right) $ | $ \varTheta \left( 1 \right) $ |
| pop  | $ O \left( ln(n) \right) $     | $ \varTheta \left( ln(n) \right) $ | $ O \left( ln(n) \right) $     |



