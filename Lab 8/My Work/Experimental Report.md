# 问题描述

利用min-heap实现Merge Sort，将M个有序队列归并为1个新的队列。

# 算法流程描述

*关于min-heap，在 Lab 6 与 Lab 7 中我们已经练习了两次了，在这个问题上可以直接利用之前学过的知识帮助我们来分析算法与构建数据结构。*

1. 利用每个队列的头元素构建一个有M个节点的min-heap；
2. pop堆顶元素 $ x $，存入目标队列 $ res $ ；
3. 若 $ x $ 所在队列还有元素，则再将该队列的头元素push进堆中；
4. pop和push的过程中都要保证min-heap的完整；
5. 如果min-heap为空，则结束；否则跳转至步骤2。

在这次实验中，我们令M为8

# 算法实现

为了方便获得需要push的元素，我利用指针来实现了队列，这样在pop之后，可以直接检查被pop元素的next指针。

# 算法测试

利用随机数生成8个数组，并且将其分别排序。

然后利用这8个数组生成队列，运行算法。

结果如下：



# 算法分析

每一次循环，我们其实是进行了一次pop与一次push。而根据Lab 6我们知道，两者的复杂度分别为 $ O \left( ln(n) \right) $ 与 $ \varTheta \left( 1 \right) $ ，因此合在一起也就是 $ O \left( ln(n) \right) $   ；

那么，进行n次操作之后，总体的复杂度就是  $ O \left( nln(n) \right) $  

