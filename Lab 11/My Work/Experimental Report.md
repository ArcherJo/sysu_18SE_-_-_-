# 问题描述

对课件中最小生成树部分的例子进行复现。

# 算法流程描述

1. 构建图的边集队列Q
2. 构建并查集，初始化每个节点分别属于不同的集合
3. 对边集队列Q进行权重的排序
4. 利用e遍历整个队列
5. 若边e的两端属于同一集合，跳过此次循环
6. 将边e的两端所属的集合进行合并，并将该边push进res队列中；继续循环
7. 返回res

# 算法实现

就是按部就班的按照老师的算法来==没什么实现细节。

# 算法测试

直接运行代码即就是老师课件上的最终结果。

# 算法分析

这节课一开始老师讲了关联矩阵，于是我实现的时候忘了看要求，直接用关联矩阵做了。

问题不大，那就重新分析一下。

## 邻接矩阵与邻接表的比较：

其实这两种表示方法对于最小生成树的流程并没有影响。

真正的区别只在生成边集数组。

### 返回节点入度

邻接表需要访问整个表。

邻接矩阵需要访问整个矩阵。

相比之下还是邻接矩阵访问了很多不存在的边。



